---
title: "Religious technology"
date: "2011-01-22"
---

I guess its in the human nature to latch on to things and like it to death. When doing this, we as humans tend to take things we like and don't like anything else within the same category - I guess with the exception of food. This is something I think can be multiplied as a truth by 10 for technologists. We tend to find a piece of technology and really go out of our way to show others how good it is and how much competing technologies in the same category suck. I do this myself way too often, and I scare myself when doing it.

**Operating Systems**  
Take operating systems, this category is probably the one with the biggest amount of fanboys in it. Windows guys will automatically dismiss OSX and Linux and vice-versa. In my opinion only a select few can agree that they all have their strengths and weaknesses. Some 3 years ago, I was the Windows version of this. I couldn't really see why anyone would even bother considering anything but Windows - till Vista made my computers miserable and I decided to try out Mac and OSX. Now, 3 years later - I scare myself in some ways with how much I have "switched" and deploy only Apple based hardware and software in my home. I say to myself; Apples stuff just works. To some extent this might be true - but trust me, there are issues with their stuff as there are with just about anything out there. I'm not necessarily so audible about my Apple likings, I'm not trying to convince people to switch - but I find myself losing perspective. When I embarked on the OSX journey 3 years ago, it was also in an attempt to broaden my horizon and leave my comfort zone, in fact I had a plan about not having a comfort zone at all. Now it seems that I'm well on my way establishing a new comfort zone - so time to break out of the new habits and yet again broaden my horizon; meet Linux.

The first time I tried Linux was back in the beginning of Red Hat days (if my memory serves me correct, around 1994 / 1995). Back then it was a bit of a pain getting all hardware working with it, so my project of becoming a Linux user was soon abandoned. Nowadays, its a far better story just taking any computer and putting any Linux distro on it. So, yesterday I decided to take my Windows Laptop and stick Ubuntu on it. It took me some 3 minutes to download it and another 7-8 minutes installing it and just about everything worked. In fact the only thing that didn't work out of the box was the trackpad. Not too stressed about that, since the trackpad on my laptop is not something I use anyways. But I know I can get it working if I just put some effort behind getting it to work.

Booted up and went to the software center and installed what I needed - basically to start with, I just needed something familiar to latch onto and got MonoDevelop to just see some C# code running. Quite happy with the experience so far.

  
**Programming Languages**  
Another aspect I see when talking to people when doing presentations or classes is the idea of the programming language they have chosen to be the only programming language that could solve their tasks. The most common thing I hear is the why C# is so much better than VB.net, and almost just as common coming from people who have yet to write a single line of VB.net code. Bringing in languages such as Ruby, Python or even Javascript - a lot of guys are just grinning and coming with remarks such as; you wouldn't do serious enterprise development in either of those languages. The latter one I'm guilty of myself. Javascript has long been something that I really couldn't get anyone doing. So, the cure for myself is to start writing Javascript and get to know it better than I do. There has to be a reason why so many are using it, and it can't be just that its the only client side language working in a browser that is the reason. It must have qualities beyond this, and I've realized working with Javascript the last year or so that it is in fact quite a cool language to work with. Different from what my comfort zone has been defined to be, but getting to know it, its quite cool. The same goes for Ruby, a language that I fell in love with after reading samples for 5 minutes. And yes, both of these can be used in professional software development and actually solve real business needs. I think for the category of programming languages, as with operating systems, its not that one suck more than other, they're just different. They are different in how you write code in them, and therefor there are different ways of achieving the same goals, and also very often there are different workflows to writing code. Saying that one is better than the other is something at least I will stop doing. I will instead try to focus more on picking the right tool for the right job.  
  

**Source Control**  
Here's a subject I have so far in my career always considered to be something I really don't care about. Just show me the tools and give me the URL for the repository and I'll start committing code. But this turns out to be something that people also gets a religious view on. My view on it has always been that its a tool for collaborating with others and also at the same time hold history of what the team is doing. Recently, in the .net world, the concept of distributed source controls has really taken off - with a good reason. They do in fact solve things that more traditional source control software doesn't, or as I'd rather say - they are doing things differently and opening up for different ways of working. I've been using Git and Mercurial the last couple of years and for the way I work with code, they have yet to solve anything for me personally. But I carry on using them in order to see if they will eventually solve something for me - again, there must be a reason why so many are embracing them. One thing I do see though, is for open source projects and distributed teams - these kind of source control systems really do solve things, and I have in fact taken advantage of a few of the features they have for these particular scenarios. The thing I'm having trouble with seeing though, is how they would be superior in a on-premise situation were the entire team is located on the same location and working together. To me there seems to be a bit too much ceremony and unsolved issues such as continuous integration with multiple branches and such. This could of-course boil down to how one works with them, but it seems to me that there is quite a big gap in the tooling experience for these. Something the more established source control systems have more right. I'm still following this track and will look for the revelation. It might come to me, or it might not. I'm open.

**  
The list goes on...**  
I could probably carry on this list forever :  
  
Flash vs. Silverlight vs. HTML 5  
SQL vs. NoSQL (Document or Object - based DBs)  
OpenGL vs. DirectX  
Java vs. .net  
  
...and so on. But really, is it really all these things that matter when we're trying to do our job? Me thinks not. For a software developer, I think it is far more important to identify the needs of the people we're creating software for and solving them in a timely fashion with code that is maintainable. My core values as a software developer is to be sure I deliver quality software - by quality software I do mean something the users agree on is good. Good in the sense that it is user friendly, but also good in the sense that it is considered stable. To accomplish this, I chose to be sure I write my code in a certain manner with certain mechanisms to try and make the code stable. I also demand that I get to work more closely with the users that will be using the software or a representative of those users to be sure I am delivering something they can in fact use and consider user friendly.

One thing I've learned throughout the years; t here are so many people out there who are smarter than me. Sure, I am guilty of sitting there thinking I'm the smartest in a few discussions, but thats just part of being human (isn't it..?? :) ).  
  

**Pragmatism**  
A turning point for my own religious technology beliefs was when I read the "[Pragmatic Programmer](http://www.pragprog.com/the-pragmatic-programmer)" a few years ago. Its doing a very good job of lifting up your head just enough to get interested in expanding your comfort zone. My goal as a developer is to be pragmatic as to what technology I chose for a specific task, what tools I use, what operating system I do them on - and instead focus on the bigger picture. This is what I define as pragmatism. To me, its not important what tools you use, but how you use those tools. If you're able to build a house without using a hammer but a stone as your tool instead, so be it - as long as the result is a good quality house.

My ultimate goal; have no comfort zone, become a technology atheist - learn learn learn, try and fail and learn some more. We as software developers are in a unique position to do this, its a young industry we can chose to take part in shaping it or not. I chose to at least try to take part.
